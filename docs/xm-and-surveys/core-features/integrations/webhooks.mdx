---
title: "Webhooks"
description: "With webhooks, you can receive real-time HTTP notifications when specific objects change in your Formbricks environment. This allows you to stay updated and trigger automated actions based on these events."
---

### **Webhook Triggers**

Webhooks are configured to send notifications based on trigger events. The available triggers include:

- **`responseCreated`**

- **`responseUpdated`**

- **`responseFinished`**

---

## **Creating Webhooks**

You can create webhooks either through the **Formbricks App UI** or programmatically via the **Webhook API**.

## **Creating Webhooks via UI**

- **Log in to Formbricks**
  and click on the `Configuration` tab in the left sidebar and then click on the `Integrations` tab.

![Step one](/images/xm-and-surveys/core-features/integrations/webhooks/integrations-tab.webp)

- Click onÂ **Manage Webhooks**Â & thenÂ **Add Webhook**Â button:

![Step two](https://res.cloudinary.com/dwdb9tvii/image/upload/v1738094259/j4a92z2q43twgamogpny.webp)

- Add your webhook listener endpoint & test it to make sure it can receive the test endpoint otherwise you will not be able to save it.

![Step three](https://res.cloudinary.com/dwdb9tvii/image/upload/v1738094617/image_kubsnz.jpg)

- Now add the triggers you want to listen to and the surveys!

- Thatâ€™s it! Your webhooks will not start receiving data as soon as it arrives!

![Step five](https://res.cloudinary.com/dwdb9tvii/image/upload/v1738094816/image_xvrel1.jpg)

## **Creating Webhooks via API**

Use our documented methods on the **Creation**, **List**, and **Deletion** endpoints of the Webhook API mentioned in our [API v2 playground](https://formbricks.com/docs/api-v2-reference/management-api-%3E-webhooks/get-webhooks).

If you encounter any issues or need help setting up webhooks, feel free to reach out to us on [GitHub Discussions](https://github.com/formbricks/formbricks/discussions). ðŸ˜ƒ

---

## Webhook Security with Standard Webhooks

Formbricks implements the [Standard Webhooks](https://github.com/standard-webhooks/standard-webhooks) specification to ensure webhook requests can be verified as genuinely originating from Formbricks.

### Webhook Headers

Every webhook request includes the following headers:

| Header              | Description                                          | Example                                |
| ------------------- | ---------------------------------------------------- | -------------------------------------- |
| `webhook-id`        | Unique message identifier                            | `019ba292-c1f6-7618-aaf2-ecf8e39d1cc7` |
| `webhook-timestamp` | Unix timestamp (seconds) when the webhook was sent   | `1704547200`                           |
| `webhook-signature` | HMAC-SHA256 signature (only if secret is configured) | `v1,K3Q2bXlzZWNyZXQ=`                  |

### Signing Secret

When you create a webhook (via the UI or API), Formbricks automatically generates a unique signing secret for that webhook. The secret follows the Standard Webhooks format: `whsec_` followed by a base64-encoded random value.

**Via UI:** After creating a webhook, the signing secret is displayed immediately. Copy and store it securelyâ€”you can also view it later in the webhook settings.

**Via API:** The signing secret is returned in the webhook creation response.

This secret is used to generate the HMAC signature included in each webhook request, allowing you to verify the authenticity of incoming webhooks.

### Signature Verification

The signature is computed as follows:

```
signed_content = "{webhook-id}.{webhook-timestamp}.{body}"
signature = base64(HMAC-SHA256(secret, signed_content))
header_value = "v1,{signature}"
```

### Validating Webhooks

To validate incoming webhook requests:

1. Extract the `webhook-id`, `webhook-timestamp`, and `webhook-signature` headers
2. Verify the timestamp is within an acceptable tolerance (e.g., 5 minutes) to prevent replay attacks
3. Decode the secret by stripping the `whsec_` prefix and base64 decoding the rest
4. Compute the expected signature using HMAC-SHA256 with the decoded secret
5. Compare your computed signature with the received signature (after stripping the `v1,` prefix)

### Node.js Verification Functions

```javascript
const crypto = require("crypto");

const WEBHOOK_TOLERANCE_IN_SECONDS = 300; // 5 minutes

/**
 * Decodes a Formbricks webhook secret (whsec_...) to raw bytes
 */
function decodeSecret(secret) {
  const base64 = secret.startsWith("whsec_") ? secret.slice(6) : secret;
  return Buffer.from(base64, "base64");
}

/**
 * Verifies the webhook timestamp is within tolerance
 * @throws {Error} if timestamp is too old or too new
 */
function verifyTimestamp(timestampHeader) {
  const now = Math.floor(Date.now() / 1000);
  const timestamp = parseInt(timestampHeader, 10);

  if (isNaN(timestamp)) {
    throw new Error("Invalid timestamp");
  }

  if (Math.abs(now - timestamp) > WEBHOOK_TOLERANCE_IN_SECONDS) {
    throw new Error("Timestamp outside tolerance window");
  }

  return timestamp;
}

/**
 * Computes the expected signature for a webhook payload
 */
function computeSignature(webhookId, timestamp, body, secret) {
  const signedContent = `${webhookId}.${timestamp}.${body}`;
  const secretBytes = decodeSecret(secret);
  return crypto.createHmac("sha256", secretBytes).update(signedContent).digest("base64");
}

/**
 * Verifies a Formbricks webhook request
 * @param {string} body - Raw request body as string
 * @param {object} headers - Object containing webhook-id, webhook-timestamp, webhook-signature
 * @param {string} secret - Your webhook secret (whsec_...)
 * @returns {boolean} true if valid
 * @throws {Error} if verification fails
 */
function verifyWebhook(body, headers, secret) {
  const webhookId = headers["webhook-id"];
  const webhookTimestamp = headers["webhook-timestamp"];
  const webhookSignature = headers["webhook-signature"];

  if (!webhookId || !webhookTimestamp || !webhookSignature) {
    throw new Error("Missing required webhook headers");
  }

  // Verify timestamp
  const timestamp = verifyTimestamp(webhookTimestamp);

  // Compute expected signature
  const expectedSignature = computeSignature(webhookId, timestamp, body, secret);

  // Extract signature from header (format: "v1,{signature}")
  const receivedSignature = webhookSignature.split(",")[1];

  if (!receivedSignature) {
    throw new Error("Invalid signature format");
  }

  // Use constant-time comparison to prevent timing attacks
  const expectedBuffer = Buffer.from(expectedSignature, "utf8");
  const receivedBuffer = Buffer.from(receivedSignature, "utf8");

  if (
    expectedBuffer.length !== receivedBuffer.length ||
    !crypto.timingSafeEqual(expectedBuffer, receivedBuffer)
  ) {
    throw new Error("Invalid signature");
  }

  return true;
}

module.exports = { verifyWebhook, decodeSecret, computeSignature, verifyTimestamp };
```

**Usage:**

```javascript
// In your webhook handler, use the raw body (not parsed JSON)
try {
  verifyWebhook(rawBody, req.headers, process.env.FORMBRICKS_WEBHOOK_SECRET);
  const payload = JSON.parse(rawBody);
  // Process verified webhook...
} catch (error) {
  // Verification failed - reject the request
  console.error("Webhook verification failed:", error.message);
}
```

<Note>
  Always use the **raw request body** (as a string) for signature verification, not the parsed JSON object.
  Parsing and re-stringifying can change the formatting and break signature validation.
</Note>

### Using Standard Webhooks Libraries

You can also use the official [Standard Webhooks libraries](https://github.com/standard-webhooks/standard-webhooks#libraries) available for various languages:

- **Node.js**: `npm install standardwebhooks`
- **Python**: `pip install standardwebhooks`
- **Go, Ruby, Java, Kotlin, PHP, Rust**: See the [Standard Webhooks GitHub](https://github.com/standard-webhooks/standard-webhooks)

---

## Example Webhook Payloads

We provide the following webhook payloads, `responseCreated`, `responseUpdated`, and `responseFinished`.

### Response Created

Example of Response Created webhook payload:

```json
[
  {
    "data": {
      "contact": null,
      "contactAttributes": null,
      "createdAt": "2025-07-24T07:47:29.507Z",
      "data": {
        "q1": "clicked"
      },
      "displayId": "displayId",
      "endingId": null,
      "finished": false,
      "id": "responseId",
      "language": "en",
      "meta": {
        "country": "DE",
        "url": "https://app.formbricks.com/s/surveyId",
        "userAgent": {
          "browser": "Chrome",
          "device": "desktop",
          "os": "macOS"
        }
      },
      "singleUseId": null,
      "survey": {
        "createdAt": "2025-07-20T10:30:00.000Z",
        "status": "inProgress",
        "title": "Customer Satisfaction Survey",
        "type": "link",
        "updatedAt": "2025-07-24T07:45:00.000Z"
      },
      "surveyId": "surveyId",
      "tags": [],
      "ttc": {
        "q1": 2154.700000047684
      },
      "updatedAt": "2025-07-24T07:47:29.507Z",
      "variables": {}
    },
    "event": "responseCreated",
    "webhookId": "webhookId"
  }
]
```

### Response Updated

Example of Response Updated webhook payload:

```json
[
  {
    "data": {
      "contact": null,
      "contactAttributes": null,
      "createdAt": "2025-07-24T07:47:29.507Z",
      "data": {
        "q1": "clicked",
        "q2": "Just browsing"
      },
      "displayId": "displayId",
      "endingId": null,
      "finished": false,
      "id": "responseId",
      "language": "en",
      "meta": {
        "country": "DE",
        "url": "https://app.formbricks.com/s/surveyId",
        "userAgent": {
          "browser": "Chrome",
          "device": "desktop",
          "os": "macOS"
        }
      },
      "singleUseId": null,
      "survey": {
        "createdAt": "2025-07-20T10:30:00.000Z",
        "status": "inProgress",
        "title": "Customer Satisfaction Survey",
        "type": "link",
        "updatedAt": "2025-07-24T07:45:00.000Z"
      },
      "surveyId": "surveyId",
      "tags": [],
      "ttc": {
        "q1": 2154.700000047684,
        "q2": 3855.799999952316
      },
      "updatedAt": "2025-07-24T07:47:33.696Z",
      "variables": {}
    },
    "event": "responseUpdated",
    "webhookId": "webhookId"
  }
]
```

### Response Finished

Example of Response Finished webhook payload:

```json
[
  {
    "data": {
      "contact": null,
      "contactAttributes": null,
      "createdAt": "2025-07-24T07:47:29.507Z",
      "data": {
        "q1": "clicked",
        "q2": "accepted"
      },
      "displayId": "displayId",
      "endingId": "endingId",
      "finished": true,
      "id": "responseId",
      "language": "en",
      "meta": {
        "country": "DE",
        "url": "https://app.formbricks.com/s/surveyId",
        "userAgent": {
          "browser": "Chrome",
          "device": "desktop",
          "os": "macOS"
        }
      },
      "singleUseId": null,
      "survey": {
        "createdAt": "2025-07-20T10:30:00.000Z",
        "status": "inProgress",
        "title": "Customer Satisfaction Survey",
        "type": "link",
        "updatedAt": "2025-07-24T07:45:00.000Z"
      },
      "surveyId": "surveyId",
      "tags": [],
      "ttc": {
        "_total": 4947.899999035763,
        "q1": 2154.700000047684,
        "q2": 2793.199999988079
      },
      "updatedAt": "2025-07-24T07:47:56.116Z",
      "variables": {}
    },
    "event": "responseFinished",
    "webhookId": "webhookId"
  }
]
```

---

## Webhook Payload Schema

Every webhook delivery contains a JSON payload with a consistent structure across all trigger types (`responseCreated`, `responseUpdated`, and `responseFinished`). The payload body and request headers follow the same format regardless of which event fired the webhook, making it straightforward to write a single handler for all Formbricks webhook events.

### Payload Body

The top-level payload object contains three fields:

| Field | Type | Description |
|---|---|---|
| `webhookId` | string | The unique identifier of the webhook configuration that triggered this delivery. |
| `event` | string | The trigger type: `responseCreated`, `responseUpdated`, or `responseFinished`. |
| `data` | object | The response data object containing all response details and an embedded survey summary. |

Source: `apps/web/app/api/(internal)/pipeline/route.ts:L102-115`

### Response Data Fields

The `data` object contains the full response record plus an embedded `survey` summary. The following fields are included:

| Field | Type | Description |
|---|---|---|
| `id` | string | The response's unique identifier. |
| `createdAt` | string (ISO 8601) | When the response was first created. |
| `updatedAt` | string (ISO 8601) | When the response was last updated. |
| `surveyId` | string | The ID of the survey this response belongs to. |
| `finished` | boolean | Whether the response has been completed (`true`) or is still in progress (`false`). |
| `data` | object | The answer data, keyed by element ID (e.g., `{"q1": "clicked", "q2": "Just browsing"}`). |
| `ttc` | object | Time-to-completion metrics per element, in milliseconds. For `responseFinished`, includes `_total` for total completion time. |
| `meta` | object | Browser and device metadata including `country`, `url`, and `userAgent` object with `browser`, `device`, and `os` fields. |
| `contactAttributes` | object \| null | Contact attributes associated with the respondent, if available. |
| `singleUseId` | string \| null | Single-use link identifier, if the response came from a single-use link. |
| `language` | string | The locale/language code of the respondent (e.g., `"en"`). |
| `variables` | object | Survey variable values captured during the response. |

### Embedded Survey Summary

The `data.survey` object provides metadata about the survey that generated the response:

| Field | Type | Description |
|---|---|---|
| `survey.title` | string | The name of the survey. |
| `survey.type` | string | The survey type (e.g., `"link"`, `"app"`, `"website"`). |
| `survey.status` | string | The survey status (e.g., `"inProgress"`, `"completed"`, `"paused"`). |
| `survey.createdAt` | string (ISO 8601) | When the survey was created. |
| `survey.updatedAt` | string (ISO 8601) | When the survey was last updated. |

### Request Headers

Every webhook request includes the following Standard Webhooksâ€“compliant headers:

| Header | Description | Example |
|---|---|---|
| `content-type` | Always `application/json` | `application/json` |
| `webhook-id` | Unique message identifier (UUID v7) | `019ba292-c1f6-7618-aaf2-ecf8e39d1cc7` |
| `webhook-timestamp` | Unix timestamp (seconds) when the webhook was dispatched | `1704547200` |
| `webhook-signature` | HMAC-SHA256 signature (only included if the webhook has a signing secret configured) | `v1,K3Q2bXlzZWNyZXQ=` |

Source: `apps/web/app/api/(internal)/pipeline/route.ts:L122-136`, `packages/database/zod/webhooks.ts`

---

## Typeform Webhook Compatibility

Formbricks and Typeform use different webhook payload structures. While Typeform fires a single `form_response` event when a form submission is completed, Formbricks provides a more granular event model with three distinct triggers â€” giving you visibility into the full response lifecycle from creation through completion.

### Trigger Mapping

The following table maps Typeform webhook events to their Formbricks equivalents:

| Typeform Event | Formbricks Trigger | Notes |
|---|---|---|
| `form_response` (completed) | `responseFinished` | Primary completion event â€” direct mapping. |
| â€” | `responseCreated` | Formbricks-specific: fires when a respondent starts a survey (no Typeform equivalent). |
| â€” | `responseUpdated` | Formbricks-specific: fires on each page/question submission before completion (no Typeform equivalent). |

### Key Structural Differences

Formbricks provides **more granular webhook events** than Typeform. With three triggers (`responseCreated`, `responseUpdated`, `responseFinished`) compared to Typeform's single `form_response` event, you can track partial submissions and monitor response progress in real time.

The payload structures also differ between the two platforms. Typeform nests answers in a `form_response.answers[]` array with field-typed values, while Formbricks uses a flat `data.data` object keyed by element IDs. This makes Formbricks payloads simpler to parse when you need to access a specific answer by its element identifier.

Both platforms support HMAC-SHA256 webhook signatures for verifying payload authenticity, but the header names and encoding formats differ. Formbricks follows the [Standard Webhooks](https://github.com/standard-webhooks/standard-webhooks) specification with `webhook-id`, `webhook-timestamp`, and `webhook-signature` headers, while Typeform uses its own signature format.

<Note>
  For a detailed field-by-field structural comparison, see the [Webhook Parity](/development/typeform-parity/webhook-parity) analysis.
</Note>
